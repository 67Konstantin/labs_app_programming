import decimal
import re


def is_divisible_by_three(binary_string: str) -> bool:
    """
    Паттерн выглядит примерно как
    Либо 0
    Либо начинается с 1 и заканчивается на 1 и между ними есть или может не быть 01*0
       01*0 значит что между 0 0 может быть любое количество 1, в том числе и не быть вообще

    И таких вот комбинаций 1 или больше раз
    """
    # Регулярное выражение, которое соответствует числам, кратным 3
    # (0|1(01*0)*1)* - это регулярка для чисел, кратных 3
    pattern = r'^(0|1(01*0)*1)+$'
    
    if not re.match(r'^[01]+$', binary_string):
        raise ValueError("Строка должна содержать только символы 0 и 1")
    
    return bool(re.fullmatch(pattern, binary_string))

if __name__ == "__main__":
    
    # Примеры использования
    test_cases = [
        "0",      
        "1",      
        "11",     
        "100",    
        "101",    
        "110",    
        "1001",   
        "1010",  
        "1100",   
        "1111", 
        "10010",
        "110101111111010110101111111010110101111111010110101111111010110101111111010110101111111010110101111111010101101101111101101101101101110101111111010110101111111010110101111111010110101111111010110101111111010110101111111010110101111111010101101101111101101101101101110101111111010110101111111010110101111111010110101111111010110101111111010110101111111010110101111111010101101101111101101101101101110101111111010110101111111010110101111111010110101111111010110101111111010110101111111010110101111111010101101101111101101101101101"
    ]
    
    print("\nПроверка бинарных чисел на кратность 3:")
    print("=" * 60)
    b = test_cases[-1]
    print(f"Число {b} в десятичной системе: {int(str(b), 2)} кратно 3: {is_divisible_by_three(str(b))}")
    # a = 12000
    # print(f"Число {bin(a)[2:]} в десятичной системе: {a} кратно 3: {is_divisible_by_three(bin(a)[2:])}")
    print("")
